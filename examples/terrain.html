<head>
  <base href=".." />
</head>
<body>
<script src="source/Type.js"></script>
<script src="source/Property.js"></script>
<script src="source/Map.js"></script>
<script src="source/Path.js"></script>
<script src="source/Quest.js"></script>
<script src="source/Action.js"></script>
<script src="source/Object.js"></script>
<script src="source/Property.js"></script>
<script src="source/Value.js"></script>
<script src="source/Coordinates.js"></script>
<script src="source/Location.js"></script>
<script src="source/Time.js"></script>
<script src="source/Reference.js"></script>
<script src="source/GL.js"></script>
<script src="data/Properties.js"></script>
<script src="data/Quests.js"></script>
<script src="data/Resources.js"></script>
<script src="data/Actions.js"></script>
<script src="data/Creatures.js"></script>
<script src="data/Items.js"></script>
<script src="lib/Seed.js"></script>
<script src="lib/gl-matrix/common.js"></script>
<script src="lib/gl-matrix/mat4.js"></script>
<script src="lib/gl-matrix/vec3.js"></script>
<script>
// fps
eval(unescape("(function()%7Bvar%20script%3Ddocument.createElement(%27script%27)%3Bscript.src%3D%27http://github.com/mrdoob/stats.js/raw/master/build/stats.min.js%27%3Bdocument.body.appendChild(script)%3Bscript%3Ddocument.createElement(%27script%27)%3Bscript.innerHTML%3D%27var%20interval%3DsetInterval(function()%7Bif(typeof%20Stats%3D%3D%5C%27function%5C%27)%7BclearInterval(interval)%3Bvar%20stats%3Dnew%20Stats()%3Bstats.domElement.style.position%3D%5C%27fixed%5C%27%3Bstats.domElement.style.left%3D%5C%270px%5C%27%3Bstats.domElement.style.top%3D%5C%270px%5C%27%3Bstats.domElement.style.zIndex%3D%5C%2710000%5C%27%3Bdocument.body.appendChild(stats.domElement)%3BsetInterval(function()%7Bstats.update()%3B%7D,1000/60)%3B%7D%7D,100)%3B%27%3Bdocument.body.appendChild(script)%3B%7D)()%3B"))
</script>
<style>

  body, html {
    padding: 0;
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  canvas ~ canvas {
    width: 70px;
    height: 70px;
  }
</style>

<canvas id="canvas"></canvas>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
  attribute vec2 position; // -1..1
  attribute vec2 texture;  //  0..1

  uniform vec2 viewport;
  uniform vec2 scroll;
  uniform mat4 matrix;
  uniform mat4 camera;
  uniform mat4 projection;
  uniform mat4 orientation;

  varying vec2 pixel;
  varying vec2 tile;

  void main() {
    vec2 pos = position;
    pos.y = - pos.y - 0.5;
    pixel = ((pos + 1.0) / 2.0 * viewport) + scroll;
    pixel.y *= 2.0;
    tile = texture;
    
    gl_Position = vec4(position, 0, 1) * matrix * projection *camera;
  }
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;

  //
  // Description : Array and textureless GLSL 2D simplex noise function.
  //      Author : Ian McEwan, Ashima Arts.
  //  Maintainer : ijm
  //     Lastmod : 20110822 (ijm)
  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
  //               Distributed under the MIT License. See LICENSE file.
  //               https://github.com/ashima/webgl-noise
  // 

  vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
  }

  float snoise(vec2 v)
    {
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                       -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
  // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);

  // Other corners
    vec2 i1;
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    // x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

  // Permutations
    i = mod289(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                  + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }


  uniform sampler2D terrain;
  uniform sampler2D subterrain;
  uniform sampler2D overlay;
  uniform sampler2D obstruction;
  uniform sampler2D objects;

  uniform sampler2D spritesLandscape;
  uniform sampler2D spritesTerrain;
  uniform sampler2D spritesTransitions;

  uniform sampler2D sprites64x64;
  uniform sampler2D sprites64x160;
  uniform sampler2D sprites192x160;

  uniform vec2 mapSize;
  uniform vec2 atlasSize;
  uniform float tileSize;
  uniform mat4 projection;
  uniform mat4 orientation;

  varying vec2 pixel;
  varying vec2 tile;

  vec2 getTilePosition(vec2 tile) {
    vec2 cell = floor(tile * mapSize);

    return vec2(
      (cell.x - cell.y) * (tileSize) 
        + (mapSize.x * tileSize ) - tileSize, 
      (cell.x + cell.y) * (tileSize / 2.0) 
    );
  }

  vec4 getColor(sampler2D texture, vec2 locals, vec2 position, vec2 grid, vec2 shift, vec2 translate) {
    vec2 offset = position * grid;
    vec2 start = getTilePosition(tile + shift / mapSize);
    vec2 diff = ((pixel - locals) - start);
    vec2 point = locals + diff + translate;
    point.x += (grid.x - tileSize * 2.0) / 2.0;
    point.y += (grid.y - tileSize) + 1.0;
    if (point.x > 0.0 && point.x < grid.x && point.y > 0.0 && point.y < grid.y)
      return texture2D(texture, (point + offset) / atlasSize);
    else 
      return vec4(0, 0, 0, 0);
  }

  // get color of a mask pixel
  // also composes any combination of corners from separate corner sprites
  vec4 getTransitionColor(vec2 locals, vec2 position, vec2 shift, vec2 translate) {
    vec2 coordinates = (tile * mapSize - floor(tile * mapSize));
    float x = position.x;
    float sprite = 0.0;
    if (x > 32.0) {
      // sw
      if (coordinates.x < 0.5 && coordinates.y > 0.5) {
        if (x == 43.0 || x == 33.0 || x == 36.0 || x == 38.0 || x == 39.0 || x == 40.0 || x == 42.0) {
          sprite = 11.0;
        }
      }
      // ne
      if (coordinates.x < 0.5 && coordinates.y < 0.5) {
        if (x == 43.0 || x == 33.0 || x == 34.0 || x == 37.0 || x == 39.0 || x == 40.0 || x == 41.0) {
          sprite = 12.0;
        }
      }
      // ne
      if (coordinates.x > 0.5 && coordinates.y < 0.5) {
        if (x == 43.0 || x == 34.0 || x == 35.0 || x == 38.0 || x == 40.0 || x == 41.0 || x == 42.0) {
          sprite = 13.0;
        }
      }
      // se
      if (coordinates.x > 0.5 && coordinates.y > 0.5) {
        if (x == 43.0 || x == 35.0 || x == 36.0 || x == 37.0 || x == 39.0 || x == 41.0 || x == 42.0) {
          sprite = 14.0;
        }
      }
      if (sprite == 0.0) {
        return vec4(0, 0, 0, 1);
      } else {
        x = sprite;
      }
    }
    position.x = x - 1.0;
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    return getColor(spritesTransitions, locals, position, grid, vec2(0, 0), translate);
  }

  vec2 getCoordinates() {
    return (tile * mapSize - floor(tile * mapSize));
  }

  vec2 getPosition(vec2 shift) {
    return ((tile * mapSize) + shift) / mapSize;
  }

  float getVariation(vec2 position, float seed) {
    return (snoise(floor(position * mapSize * seed)) + 1.0) / 2.0;
  }
  float getRandom(vec2 position, float range, float seed) {
    return floor(getVariation(position, seed) * range);
  }

  vec2 getTranslation(vec2 shift) {
    vec2 coordinates = getCoordinates();
    vec2 translate = vec2(0,0);
    float pixel = 1.0 - 1.0 / tileSize;
    if ((coordinates.x > pixel && coordinates.y >  1.0 / tileSize / 2.0) 
    || (coordinates.y > pixel && coordinates.x > 1.0 / tileSize / 2.0) )
      translate.y -= 1.0;


    return translate;
  }

  vec4 getBestCorner(vec2 pos, float threshold, float variation, vec2 first, vec2 second, vec2 third) {
    vec4 result = vec4(0,0,0,0);
    float results = 0.0;
    vec4 a = result;
    vec4 b = result;
    vec4 c = result;
    vec4 corner = floor(texture2D(terrain, pos + first / mapSize) * 255.0);
    if (corner.b < threshold) {
      a = corner;
      results++;
    }
    corner = floor(texture2D(terrain, pos + second / mapSize) * 255.0);
    if (corner.b < threshold) {
      if (results == 1.0)
        b = corner;
      else
        a = corner;
      results++;
    }
    corner = floor(texture2D(terrain, pos + third / mapSize) * 255.0);
    if (corner.b < threshold) {
      if (results == 2.0)
        c = corner;
      if (results == 1.0)
        b = corner;
      else
        a = corner;
      results++;
    }
    if (results > 0.0) {
      float choice = floor(results * (variation));
      if (choice == 2.0)
        result = c;
      else if (choice == 1.0)
        result = b;
      else
        result = a;
    }
    return result;
  }

  vec4 getCorner(vec2 locals, vec2 shift, vec2 translate, float threshold) {
    vec2 coordinates = getCoordinates();
    vec2 now = floor(tile * mapSize + shift);
    float variation = getVariation(floor(now + coordinates * tileSize), 1.0);
    float halfSize = tileSize / 2.0;
    float thirdSize = tileSize / 1.5;
    float sixthSize = tileSize / 3.0;
    vec2 pos = now / mapSize;
    if (coordinates.x < 1.0 / 3.0 && coordinates.y < 1.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, -1), vec2(-1, 0), vec2(0, -1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x > 2.0 / 3.0 && coordinates.y < 1.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, -1), vec2(0, -1), vec2(1,0));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x > 2.0 / 3.0 && coordinates.y > 2.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, 1), vec2(1, 0), vec2(0, 1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 3.0 && coordinates.y > 2.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, 1), vec2(-1, 0), vec2(0, 1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 2.0 && coordinates.y < 1.0 / 2.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, 0), vec2(-1, 0), vec2(-1, -1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x > 1.0 / 2.0 && coordinates.y < 1.0 / 2.0){
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(0, -1), vec2(1, 0), vec2(1, -1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x > 1.0 / 2.0 && coordinates.y > 1.0 / 2.0){
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, 0), vec2(0, 1), vec2(1, 1));
      if (corner.b > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 2.0 && coordinates.y > 1.0 / 2.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(0, 1), vec2(-1, 0), vec2(-1, 1));
      if (corner.b > 0.0)
        return corner;
    }
    /**/
    return vec4(0,0,0,0);
  }


  vec4 getTerrainColor(vec2 locals, vec2 shift) {
    vec2 position = getPosition(shift);
    vec4 location = floor(texture2D(terrain, position) * 255.0);
    vec2 translate = getTranslation(shift);
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    vec2 here = vec2(0, 0);
    float variation = getRandom(position, 4.0, 1.0);
    if (location.a > 0.0) {
      vec2 mask = vec2(location.a, 1);
      vec4 masked = getTransitionColor(locals, mask, here, translate);
      if (masked.a == 0.0) {
        vec4 corner = getCorner(locals, shift, translate, location.b);
        if (corner.b > 0.0) {
          return getColor(spritesTerrain, locals, vec2(variation, corner.b - 1.0), grid, vec2(0,0), translate);
        }
        //return vec4(0,0,0,0);
      }
    }
    vec2 terrain = vec2(variation, location.b - 1.0);
    return getColor(spritesTerrain, locals, terrain, grid, vec2(0, 0), translate);
  }

  vec4 getOverlayColor(vec2 locals, vec2 shift) {
    vec2 position = getPosition(shift);
    vec4 location = floor(texture2D(overlay, position) * 255.0);
    vec2 translate = getTranslation(shift);
    if (location.b == 0.0)
      return vec4(0, 0, 0, 0);
    if (location.a > 0.0) {
      vec2 mask = vec2(location.a, 0);
      vec4 masked = getTransitionColor(locals, mask, vec2(0, 0), translate);
      if (!(masked.r == 0.0 && masked.g == 0.0 && masked.b == 0.0 && masked.a == 1.0))
        return masked;
    }
    float variation = getRandom(shift, 4.0, 1.0);
    vec2 terrain = vec2(variation, 4.0);
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    return getColor(spritesTerrain, locals, terrain, grid, vec2(0, 0), translate);
  }

  vec4 getObjectColor(vec2 locals, vec2 shift) {
    vec2 now = tile * mapSize + shift;
    if (now.y > mapSize.y || now.x > mapSize.x)
      return vec4(0, 0, 0, 0);
    vec2 pos = floor(now) / mapSize;
    vec4 location = texture2D(objects, pos);
    vec4 object = floor(location * 255.0);
    vec2 translate = vec2(0, 0);

    if (object.a > 0.0) {
      if (object.x >= 200.0) {
        vec2 grid192x160 = vec2(tileSize * 6.0, tileSize * 5.0);
        object.x -= 200.0;
        return getColor(sprites192x160, locals, object.xy, grid192x160, shift, translate);
      } else if (object.x >= 100.0) {
        object.x -= 100.0;
        vec2 grid64x160 = vec2(tileSize * 2.0, tileSize * 5.0);
        return getColor(sprites64x160, locals, object.xy, grid64x160, shift, translate);
      } else {
        vec2 grid64x64 = vec2(tileSize * 2.0, tileSize * 2.0);
        return getColor(sprites64x64, locals, object.xy, grid64x64, shift, translate);
      }
    }
    return vec4(0, 0, 0, 0);
  }

  vec4 blend(vec4 overlay, vec4 color, float mode) {
    if (color.a == 1.0)
      return color;
    if (overlay.a == 0.0)
      return color;

    overlay.a *= mode;
    overlay.rgb *= overlay.a;
    color.rgb *= color.a;
    vec3 blended = overlay.rgb + ((1.0-overlay.a)*color.rgb);
    float alpha = color.a + (1.0-color.a)*overlay.a;
    return vec4(blended, 1);
  }

  float getZValue(vec2 shift, float heighted) {
    vec2 now = floor(tile * mapSize + shift);
    vec2 pos = now / mapSize;
    vec4 location = texture2D(subterrain, pos);
    float rating = location.r - 0.5;
    float height = floor(rating * 128.0);
    if (heighted > 0.0)
      now += vec2(height, height) + vec2(1,1);
    vec2 origin = now / mapSize;
    return location.r + floor((origin.y * mapSize.y + origin.x) * mapSize.x * mapSize.y);
  }

  vec4 getZColor(sampler2D texture, vec2 locals, vec2 position, vec2 grid, vec2 shift, vec2 translate, vec4 color) {
    float score = getZValue(shift, 1.0);
    if (color.a == 0.0 || color.a < score) {
      vec4 result = getColor(texture, locals, position, grid, shift, translate);
      if (result.a > 0.0) {
        result.a = score;
        return result;
      }
    }
    return color;
  }

  vec4 getZObjectColor(vec2 locals, vec2 shift, float threshold, vec4 color) {
    float score = 0.0;
    if (threshold > 0.0)
      score = getZValue(shift, 0.0);
    if (threshold <= score) {
      vec4 result = getObjectColor(locals, shift);
      return blend(result, color, 1.0);
    }
    return color;
  }

  vec4 getSubterrainColor(vec4 obstruction, vec2 locals, vec2 shift) {
    vec4 color = vec4(0, 0, 0, 0);
    vec2 position = vec2(0, 0);
    vec2 translate = vec2(0, 0);
    vec2 grid = vec2(tileSize * 2.0, tileSize * 2.0);
    if (obstruction.a >= 64.0) {
      obstruction.a -= 64.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(2, 2), translate, color);
    }
    if (obstruction.a >= 32.0) {
      obstruction.a -= 32.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(1, 2), translate, color);
    }
    if (obstruction.a >= 16.0) {
      obstruction.a -= 16.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(2, 1), translate, color);
    }
    if (obstruction.a >= 8.0) {
      obstruction.a -= 8.0;
      if (color.a == 0.0) {
        color = getTerrainColor(locals, vec2(1, 1));
        if (color.a > 0.0)
          color.a = getZValue(vec2(1,1), 1.0);
      }
      color = getZColor(spritesLandscape, locals, position, grid, vec2(1, 1), translate, color);
    }
    if (obstruction.a >= 4.0) {
      obstruction.a -= 4.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(0, 1), translate, color);
    }
    if (obstruction.a >= 2.0) {
      obstruction.a -= 2.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(1.0, 0.0), translate, color);
    }
    if (obstruction.a >= 1.0) {
      obstruction.a -= 1.0;
      color = getZColor(spritesLandscape, locals, position, grid, vec2(0.0, 0.0), translate, color);
    }
    return color;
  }

  // obstruction map encodes offsets to neighbour tiles
  // that have sprites big enough to obstruct given pixel

  // this function decodes that information
  // and does necessary texture lookups
  vec4 getObstructionColor(vec2 locals, vec2 shift) {
    vec2 now = floor(tile * mapSize + shift);
    vec2 pos = now / mapSize;
    vec4 color = vec4(0, 0, 0, 0);
    vec4 location = texture2D(obstruction, pos);
    vec4 obstruction = floor(location * 255.0);
    vec4 subterrain = vec4(0,0,0,0);
    float threshold = 0.0;
    if (obstruction.a > 0.0) {
      subterrain = getSubterrainColor(obstruction, locals, shift);
      if (subterrain.a > 0.0) {
        threshold = subterrain.a;
        subterrain.a = 1.0;
      }
    }

    // 4th row
    if (obstruction.r >= 128.0) {
      obstruction.r -= 128.0;
      color = getZObjectColor(locals, shift + vec2(4, 4), threshold, color);
    }
    if (obstruction.r >= 64.0) {
      obstruction.r -= 64.0; 
      color = getZObjectColor(locals, shift + vec2(3, 4), threshold, color);
    }
    if (obstruction.r >= 32.0) {
      obstruction.r -= 32.0; 
      color = getZObjectColor(locals, shift + vec2(4, 3), threshold, color);
    }

    // 3d row
    if (obstruction.r >= 16.0) {
      obstruction.r -= 16.0;
      color = getZObjectColor(locals, shift + vec2(2, 4), threshold, color);
    }
    if (obstruction.r >= 8.0) {
      obstruction.r -= 8.0;
      color = getZObjectColor(locals, shift + vec2(3, 3), threshold, color);
    }
    if (obstruction.r >= 4.0) {
      obstruction.r -= 4.0;
      color = getZObjectColor(locals, shift + vec2(4, 2), threshold, color);
    }
    if (obstruction.r >= 2.0) {
      obstruction.r -= 2.0;
      color = getZObjectColor(locals, shift + vec2(1, 4), threshold, color);
    }
    if (obstruction.r >= 1.0) {
      obstruction.r -= 1.0;
      color = getZObjectColor(locals, shift + vec2(2, 3), threshold, color);
    }
    if (obstruction.g >= 128.0) {
      obstruction.g -= 128.0;
      color = getZObjectColor(locals, shift + vec2(3, 2), threshold, color);
    }
    if (obstruction.g >= 64.0) {
      obstruction.g -= 64.0;
      color = getZObjectColor(locals, shift + vec2(4, 1), threshold, color);
    }


    // 2nd row
    if (obstruction.g >= 32.0) {
      obstruction.g -= 32.0;
      color = getZObjectColor(locals, shift + vec2(0, 4), threshold, color);
    }
    if (obstruction.g >= 16.0) {
      obstruction.g -= 16.0;
      color = getZObjectColor(locals, shift + vec2(1, 3), threshold, color);
    }
    if (obstruction.g >= 8.0) {
      obstruction.g -= 8.0;
      color = getZObjectColor(locals, shift + vec2(2, 2), threshold, color);
    }
    if (obstruction.g >= 4.0) {
      obstruction.g -= 4.0;
      color = getZObjectColor(locals, shift + vec2(3, 1), threshold, color);
    }
    if (obstruction.g >= 2.0) {
      obstruction.g -= 2.0;
      color = getZObjectColor(locals, shift + vec2(4, 0), threshold, color);
    }
    if (obstruction.g >= 1.0) {
      obstruction.g -= 1.0;
      color = getZObjectColor(locals, shift + vec2(0, 3), threshold, color);
    }
    if (obstruction.b >= 128.0) {
      obstruction.b -= 128.0;
      color = getZObjectColor(locals, shift + vec2(1, 2), threshold, color);
    }

    if (obstruction.b >= 64.0) {
      obstruction.b -= 64.0;
      color = getZObjectColor(locals, shift + vec2(2, 1), threshold, color);
    }
    if (obstruction.b >= 32.0) {
      obstruction.b -= 32.0;
      color = getZObjectColor(locals, shift + vec2(3, 0), threshold, color);
    }

    // 1st row
    if (obstruction.b >= 16.0) {
      obstruction.b -= 16.0;
      color = getZObjectColor(locals, shift + vec2(0, 2), threshold, color);
    }
    if (obstruction.b >= 8.0) {
      obstruction.b -= 8.0;
      color = getZObjectColor(locals, shift + vec2(1, 1), threshold, color);
    }
    if (obstruction.b >= 4.0) {
      obstruction.b -= 4.0;
      color = getZObjectColor(locals, shift + vec2(2, 0), threshold, color);
    }
    if (obstruction.b >= 2.0) {
      obstruction.b -= 2.0;
      color = getZObjectColor(locals, shift + vec2(0, 1), threshold, color);
    }
    if (obstruction.b >= 1.0) {
      obstruction.b -= 1.0;
      color = getZObjectColor(locals, shift + vec2(1, 0), threshold, color);
    }
    if (obstruction.a > 0.0) {
      if (threshold > 0.0) {
        float height = (threshold - floor(threshold)) * 255.0 - 127.0;
      }
      color = blend(subterrain, color, 1.0);
    }


    return color;
  }

  void main() {
    vec2 locals = pixel - getTilePosition(tile);
    vec2 shift = vec2(0, 0);
    vec4 color = vec4(0,0,0,0);
    color = blend(color, getObstructionColor(locals, shift), 1.0);
    if (color.a < 1.0) {
      color = blend(color, getObjectColor(locals, shift), 1.0);
      if (color.a < 1.0) {
        color = blend(color, getOverlayColor(locals, shift), 1.0);
        if (color.a < 1.0) {
          color = blend(color, getTerrainColor(locals, shift), 1.0);
        }
      }
    }
    gl_FragColor = color;
  }
</script>


<script>
  var options = {
    zoom: 2,
    mapSize: 32,
    tileSize: 32
  };
  var seed = parseFloat(location.search.split('seed=')[1]) || Math.random();
  
  Math.seedrandom(seed)
  var random2 = Math.random;
  Math.seedrandom(seed)

  var canvas    = document.getElementById('canvas');

  var gl        = GL(canvas);
  var vertex    = GL.Script(gl, '2d-vertex-shader')
  var fragment  = GL.Script(gl, '2d-fragment-shader')
  var program   = GL.Program(gl, [vertex, fragment])

  // look up where the vertex data needs to go.
  var position  = GL.Program.Attribute(gl, program, 'position');
  var texture   = GL.Program.Attribute(gl, program, 'texture');

  var tileSize    = GL.Program.Uniform(gl, program, 'tileSize');
  var mapSize     = GL.Program.Uniform(gl, program, 'mapSize');
  var atlasSize   = GL.Program.Uniform(gl, program, 'atlasSize');
  var viewport    = GL.Program.Uniform(gl, program, 'viewport');
  var scroll      = GL.Program.Uniform(gl, program, 'scroll');
  var matrix      = GL.Program.Uniform(gl, program, 'matrix');
  var camera      = GL.Program.Uniform(gl, program, 'camera');
  var projection  = GL.Program.Uniform(gl, program, 'projection');
  var orientation = GL.Program.Uniform(gl, program, 'orientation');

  var terrain     = GL.Program.Uniform(gl, program, 'terrain');
  var subterrain  = GL.Program.Uniform(gl, program, 'subterrain');
  var overlay     = GL.Program.Uniform(gl, program, 'overlay');
  var objects     = GL.Program.Uniform(gl, program, 'objects');
  var obstruction = GL.Program.Uniform(gl, program, 'obstruction');


  var geometry = [
    //x  y    u  v
      0,-0.5, 1, 1,
     -1, 0,   0, 1,
      1, 0,   1, 0,

     -1, 0,   0, 1,
      0, 0.5, 0, 0,
      1, 0,   1, 0,
  ];

  var Textures = {
    'spritesTerrain':     'examples/sprites/terrain.png',
    'spritesLandscape':   'examples/sprites/landscape.png',
    'spritesTransitions': 'examples/sprites/transitions.png',
    'sprites64x64':       'examples/sprites/sprites64x64.png',
    'sprites64x160':      'examples/sprites/sprites64x160.png',
    'sprites192x160':     'examples/sprites/sprites192x160.png'
  };


  var textures = {};
  var loading = [];

  for (var name in Textures) {
    !function(name) {
      loading.push(name);
      load(Textures[name], function() {
        var texture = textures[name] = {
          image: this,
          location: GL.Program.Uniform(gl, program, name) 
        }
        loading.pop();
        if (!loading.length)
          render()
      })
    }(name)
  }

  var markSubterrain = function(terrain, subterrain, obstruction, i, pos, diff, x, y, value) {
    var shift = x + y * options.mapSize;
    var target = pos - shift;
    var bitmask = obstruction.data[target * 4 + 3];
    var result = bitmask | value;
    var alpha = terrain.data[i * 4] - diff * 2;
    obstruction.data[target * 4 + 3] = result;
    if (alpha > subterrain.data[pos * 4]) {
      subterrain.data[pos * 4 + 0] = alpha;
      subterrain.data[pos * 4 + 1] = terrain.data[i * 4 + 1];
      subterrain.data[pos * 4 + 2] = terrain.data[i * 4 + 2];
      subterrain.data[pos * 4 + 3] = terrain.data[i * 4 + 3];
    }
  }

  var generateTerrainAndSubterrain = function() {
    var terrain = getImageData('terrain');
    var subterrain = getImageData('subterrain');
    var obstruction = getImageData('obstruction');
    for (var i = 0, j = Math.pow(options.mapSize, 2); i < j; i++) {
      // landscape
      terrain.data[i * 4 + 1] = Math.floor(Math.random() * 2);
      // terrain
      terrain.data[i * 4 + 2] = Math.floor(Math.random() * 4) + 1;
      // terrain mask
      setPattern(terrain, i, options.mapSize, 3, true)
      // level
      terrain.data[i * 4] = 127;
      if (Math.random() > 0.9 || matchRegion(terrain, i, options.mapSize, mountians)) {
        if (location.search.indexOf('flat') > -1)
          var height = 0;
        else
          var height = Math.floor(random2() * 4);
        terrain.data[i * 4] += height * 2;
        for (var k = 0; k <= height; k++) {
          var pos = i - k * options.mapSize - k;
          var diff = height - k;
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 2, 2, 64);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 1, 2, 32);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 2, 1, 16);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 1, 1, 8);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 0, 1, 4);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 1, 0, 2);
          markSubterrain(terrain, subterrain, obstruction, i, pos, diff, 0, 0, 1);
        }
      }
    }
    return {
      terrain: terrain,
      subterrain: subterrain
    };
  }

  var water = [
    [12, 10, 8, 5],
    //[21, 10, 0, 0],
    [15, 17, 0, 3],
    [14, 20, 0, 0],
    [12, 21, 1, 0],
    [14, 18, 5, 0],
    [18, 17, 0, 3],
    [17, 21, 0, 0],
  ];

  var mountians = [
    //[8, 14, 1, 1],
    //[10, 20, 0, 1]
  ]

  var matchRegion = function(data, i, width, regions) {
    var x = i % width
    var y = Math.floor(i / width);
    for (var pool, j = 0; pool = regions[j++];) {
      if (x >= pool[0] && y >= pool[1] && x <= pool[0] + pool[2] && y <= pool[1] + pool[3]) {
        return pool;
        break;
      }
    }
  }

  var generateOverlay = function() {
    var data = getImageData('overlay');
    for (var i = 0, j = Math.pow(options.mapSize, 2); i < j; i++) {
      // cover
      data.data[i * 4 + 0] = 0;
      // cover mask
      data.data[i * 4 + 1] = Math.floor(Math.random() * 2);
      // water
      data.data[i * 4 + 2] = matchRegion(data, i, options.mapSize, water) ? 1 : 0;
      // water mask
      setPattern(data, i, options.mapSize, 3, true)
    }
    return data;
  }

  // patterns for auto-tiling
  // matches tiles against transitions spritesheet
  var patterns = [
    // 4 sides
    [2 | 8 | 16 | 64, 9],
    // 3 sides
    [2 | 16 | 64, 21],
    [8 | 16 | 64, 22],
    [8 | 2 | 64, 23],
    [8 | 16 | 2, 24],
    // 2 sides + corner
    [8 | 64 | 4, 17],
    [8 | 2 | 128, 18],
    [2 | 16 | 32, 19],
    [1 | 64 | 16, 20],
    // 2 sides
    [64 | 8, 1],
    [8 | 2, 3],
    [2 | 16, 5],
    [64 | 16, 7],
    [2 | 64, 15],
    [8 | 16, 16],
    // 1 side
    [8, 2],
    [2, 4],
    [16, 6],
    [64, 8],
    // 4 corners
    [1 | 4 | 32 | 128, 43],
    // 2 corners
    [32 | 1, 33],
    [1 | 4, 34],
    [4 | 128, 35],
    [32 | 128, 36],
    [1 | 128, 37],
    [32 | 4, 38],
    // 3 corners
    [32 | 1 | 128, 39],
    [32 | 1 | 4, 40],
    [1 | 4 | 128, 41],
    [4 | 32 | 128, 42],
    // 1 corner
    [32, 11],
    [1, 12],
    [4, 13],
    [128, 14],

  ]


  var getPattern = function(data, i, width, raw) {
    var type = getTerrainType(data, i);
    var result = 0;
    if (getTerrainType(data, i - width - 1) < type)
      result |= 1
    if (getTerrainType(data, i - width) < type)
      result |= 2
    if (getTerrainType(data, i - width + 1) < type)
      result |= 4
    if (getTerrainType(data, i - 1) < type)
      result |= 8
    if (getTerrainType(data, i + 1) < type)
      result |= 16
    if (getTerrainType(data, i + width - 1) < type)
      result |= 32
    if (getTerrainType(data, i + width) < type)
      result |= 64
    if (getTerrainType(data, i + width + 1) < type)
      result |= 128
    if (raw)
      return result;
    if (result)
      for (var i = 0, pattern; pattern = patterns[i++];)
        if ((result & pattern[0]) == pattern[0])
          return pattern[1]
    return 0;
  }

  var setPattern = function(data, i, width, offset, around) {
    data.data[i * 4 + offset] = getPattern(data, i, width, false, offset);
    if (!around) return;
    setPattern(data, i - width - 1, width, offset)
    setPattern(data, i - width, width, offset)
    setPattern(data, i - width + 1, width, offset)
    setPattern(data, i - 1, width, offset)
    setPattern(data, i + 1, width, offset)
    setPattern(data, i + width - 1, width, offset)
    setPattern(data, i + width, width, offset)
    setPattern(data, i + width + 1, width, offset)
  }

  var getTerrainType = function(data, i) {
    return data.data[i * 4 + 2];
  }

  var obstructObject = function(obstruction, i, x, y, channel, value) { 
    var shift = ((y * options.mapSize) + x);
    var pos = (i - shift) * 4;
    obstruction.data[pos + channel] |= value
  }
  var generateObject = function(data, obstruction, i, size, x, y) {
    if (size == null)
      var size = Math.floor(Math.random() * 3);
    switch (size) {
      case 0:
        data.data[i * 4 + 0] = Math.floor(Math.random() * 9);
        data.data[i * 4 + 1] = Math.floor(Math.random() * 2);
        obstructObject(obstruction, i, 1, 1, 2, 8);
        obstructObject(obstruction, i, 0, 1, 2, 2);
        obstructObject(obstruction, i, 1, 0, 2, 1);

        break;
      case 1:
        data.data[i * 4 + 0] = (x != null ? x : Math.floor(Math.random() * 6)) + 100;
        data.data[i * 4 + 1] = y != null ? y : Math.floor(Math.random() * 1);
        obstructObject(obstruction, i, 4, 4, 0, 128);
        obstructObject(obstruction, i, 3, 4, 0, 64);
        obstructObject(obstruction, i, 4, 3, 0, 32);
        obstructObject(obstruction, i, 3, 3, 0, 8);
        obstructObject(obstruction, i, 2, 3, 0, 1);
        obstructObject(obstruction, i, 3, 2, 1, 128);
        obstructObject(obstruction, i, 2, 2, 1, 8);
        obstructObject(obstruction, i, 1, 2, 2, 128);
        obstructObject(obstruction, i, 2, 1, 2, 64);
        obstructObject(obstruction, i, 1, 1, 2, 8);
        obstructObject(obstruction, i, 0, 1, 2, 2);
        obstructObject(obstruction, i, 1, 0, 2, 1);
        break;
      case 2:
        data.data[i * 4 + 0] = (x != null ? x : Math.floor(Math.random() * 2)) + 200;
        data.data[i * 4 + 1] = y != null ? y : Math.floor(Math.random() * 1);
        obstructObject(obstruction, i, 4, 4, 0, 128);
        obstructObject(obstruction, i, 3, 4, 0, 64);
        obstructObject(obstruction, i, 4, 3, 0, 32);
        obstructObject(obstruction, i, 2, 4, 0, 16);
        obstructObject(obstruction, i, 3, 3, 0, 8);
        obstructObject(obstruction, i, 4, 2, 0, 4);
        obstructObject(obstruction, i, 1, 4, 0, 2);
        obstructObject(obstruction, i, 2, 3, 0, 1);
        obstructObject(obstruction, i, 3, 2, 1, 128);
        obstructObject(obstruction, i, 4, 1, 1, 64);
        obstructObject(obstruction, i, 0, 4, 1, 32);
        obstructObject(obstruction, i, 1, 3, 1, 16);
        obstructObject(obstruction, i, 2, 2, 1, 8);
        obstructObject(obstruction, i, 3, 1, 1, 4);
        obstructObject(obstruction, i, 4, 0, 1, 2);
        obstructObject(obstruction, i, 0, 3, 1, 1);
        obstructObject(obstruction, i, 1, 2, 2, 128);
        obstructObject(obstruction, i, 2, 1, 2, 64);
        obstructObject(obstruction, i, 3, 0, 2, 32);
        obstructObject(obstruction, i, 0, 2, 2, 16);
        obstructObject(obstruction, i, 1, 1, 2, 8);
        obstructObject(obstruction, i, 2, 0, 2, 4);
        obstructObject(obstruction, i, 0, 1, 2, 2);
        obstructObject(obstruction, i, 1, 0, 2, 1);
        break;
    }
    data.data[i * 4 + 3] = 255;
    return data;
  }

  var canvases = {};
  var getCanvas = function(name) {
    var canvas = canvases[name];
    if (!canvas) {
      canvas = document.createElement('canvas')
      var context = canvas.getContext('2d');
      canvas.height = options.mapSize;
      canvas.width = options.mapSize;
      canvases[name] = canvas;
    }
    return canvas;
  }

  var datas = {};
  var getImageData = function(name) {
    var data = datas[name];
    if (!data) {
      var canvas = getCanvas(name);
      var data = canvas.getContext('2d').createImageData(options.mapSize, options.mapSize);
      datas[name] = data;
    }
    return data; 
  }

  var setImageData = function(name, data) {
    getCanvas(name).getContext('2d').putImageData(data, 0, 0)
  }

  var generateObjectsAndObstruction = function() {
    var objects = getImageData('objects')
    var obstruction = getImageData('obstruction');


    generateObject(objects, obstruction, 425, 2, 1, 0);
    generateObject(objects, obstruction, 425 + 64 - 2, 2, 1, 0);
    generateObject(objects, obstruction, 425 + 193, 2, 1, 0);
    
    //for (var i = 0; i < width * height / 5 ; i++) {
    //  for (var pos; pos = Math.floor(Math.random() * (options.mapSize * options//.mapSize));)
    //    if (!data.data[pos * 4 + 3])
    //      break; 
    //  generateObject(objects, obstruction, pos);
    //}

    return {
      objects: objects,
      obstruction: obstruction
    }
  }
  //gl.enable(gl.CULL_FACE);
  //gl.enable(gl.DEPTH_TEST)
  var buffer;
  var objectsAndObstruction = generateObjectsAndObstruction()
  var terrainAndSubterrain = generateTerrainAndSubterrain()

  var terrainData = terrainAndSubterrain.terrain;
  var subterrainData = terrainAndSubterrain.subterrain;
  var overlayData = generateOverlay()
  var objectsData = objectsAndObstruction.objects;
  var obstructionData = objectsAndObstruction.obstruction;

  document.body.appendChild(getCanvas('terrain'));
  document.body.appendChild(getCanvas('subterrain'));
  document.body.appendChild(getCanvas('objects'));
  document.body.appendChild(getCanvas('obstruction'));
  document.body.appendChild(getCanvas('overlay'));

  var depth = window.devicePixelRatio || 1;
  var view = true
  window.onresize = function() {
    view = true;
  }
  var i = 0;
  var limit = 100;//Infinity;
  var repeat = 1;
  function render() {
    //if (i > 0)
    if (location.search.indexOf('profile') > -1) console.profile(i);
    for (var r = 0; r < repeat; r++) {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    //console.profile(i);
    // provide texture coordinates for the map.
    if (!buffer) {
      buffer = GL.Buffer(gl, 'array', new Float32Array(geometry));

      // set meta data
      gl.uniform2f(atlasSize, textures.spritesTerrain.image.width, textures.spritesTerrain.image.height);
      gl.uniform2f(mapSize, options.mapSize, options.mapSize);
      gl.uniform1f(tileSize, 32);

      // iterate geometry in pairs of two
      gl.enableVertexAttribArray(position);
      gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0);

      gl.enableVertexAttribArray(texture);
      gl.vertexAttribPointer(texture, 2, gl.FLOAT, false, 16, 8);

      // upload & assign textures
      GL.Texture(gl, 0, terrainData, true);
      GL.Texture(gl, 1, subterrainData, true);
      GL.Texture(gl, 2, overlayData, true);
      GL.Texture(gl, 3, objectsData, true);
      GL.Texture(gl, 4, obstructionData, true);
      

      gl.uniform1i(terrain, 0);
      gl.uniform1i(subterrain, 1);
      gl.uniform1i(overlay, 2);
      gl.uniform1i(objects, 3);
      gl.uniform1i(obstruction, 4);
      var k = 4;
      for (var name in textures) {
        if (!textures[name].location)
          continue
        k++;
        gl.uniform1i(textures[name].location, k);
        GL.Texture(gl, k, textures[name].image, true)

      }

      
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    }
    if (view) {
      canvas.width = window.innerWidth * depth;
      canvas.height = window.innerHeight * depth;
      gl.uniformMatrix4fv(camera, false, getCamera());
      gl.uniformMatrix4fv(matrix, false, getMatrix());
      gl.uniformMatrix4fv(projection, false, getProjection());
      gl.uniformMatrix4fv(orientation, false, getOrientation());
      view = null;
    }
    // set resolution
    var h = gl.drawingBufferHeight;
    var w = gl.drawingBufferWidth
    var max = options.mapSize * options.tileSize;
    var total = Math.max(h, w)
    var ratio = w / h;
    
    gl.uniform2f(viewport, options.mapSize * options.tileSize * 2, options.mapSize * options.tileSize);

    gl.viewport(0, 0, w, h);

    gl.uniform2f(scroll, 0, 0);

    // Draw the thing.
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
    if (location.search.indexOf('profile') > -1) console.profileEnd(i);
    // schedule next frame
    if (i < limit)
      requestAnimationFrame(function() {
        render()
      });
    i++;
    for (var name in canvases)
      if (canvases[name].offsetHeight)
        setImageData(name, getImageData(name));
  }


  function load(src, callback) {
    var img = new Image;
    img.onload = callback;
    img.src = src;
    return img;
  }

  function getCamera() {
    var direction = mat4.create()
    var camera = mat4.create()
    
    // set up camera direction
    //mat4.lookAt(direction, [0, 0, 1], [0, 0, 0], [0, 1, 0])

    // create and apply perspective
    //mat4.perspective(camera, 90 * Math.PI / 180, window.innerWidth / window.innerHeight, 0.1, 1000)

    //mat4.ortho(camera, -1, 1, -1, 1, -1, 1)

    // handle canvas aspect ratio (makes everything squared)
    camera[0] = 1 / (window.innerWidth / window.innerHeight)

    //mat4.multiply(camera, camera, direction)
    //mat4.multiply(camera, camera, projection)


    return camera
  }

  function getOrientation() {

    var orientation = mat4.create()
    mat4.rotate(orientation, orientation, 90 * Math.PI / 180, [0, 0, 1]);

    mat4.rotate(orientation, orientation, 60 * Math.PI / 180, [1, 0 , 0]);
    mat4.rotate(orientation, orientation, 45 * Math.PI / 180, [0, 0, 1]);
    //mat4.scale(orientation, orientation, [1, 1, 1])

    return orientation;
  };

  function getProjection() {
    // rotate view (isometric projection)
    var projection = mat4.create()
    //mat4.rotate(projection, projection, 45 * Math.PI / 180, [0, 0//, 1]);
    //mat4.rotate(projection, projection, 60 * Math.PI / 180, [1, 0 //, 0]);
    return projection;
  }

  function getMatrix() {
    var matrix = mat4.create()

    // scale by ratio
    // mat4.scale(matrix, matrix, [ (mapImage.width / mapImage.height), 1, 1])

    // scale map up, to make units equal device pixels
    var ratio = (options.mapSize * options.tileSize / window.innerHeight) * options.zoom// * 1.4
    mat4.scale(matrix, matrix, [ ratio, ratio, ratio])
    return matrix
  }

</script>

