<head>
  <base href=".." />
</head>
<body>
<!--
<script src="source/Type.js"></script>
<script src="source/Property.js"></script>
<script src="source/Map.js"></script>
<script src="source/Path.js"></script>
<script src="source/Quest.js"></script>
<script src="source/Action.js"></script>
<script src="source/Object.js"></script>
<script src="source/Property.js"></script>
<script src="source/Value.js"></script>
<script src="source/Coordinates.js"></script>
<script src="source/Location.js"></script>
<script src="source/Time.js"></script>
<script src="source/Reference.js"></script>
-->
<script src="source/GL.js"></script>
<!-- 
<script src="data/Properties.js"></script>
<script src="data/Quests.js"></script>
<script src="data/Resources.js"></script>
<script src="data/Actions.js"></script>
<script src="data/Creatures.js"></script>
<script src="data/Items.js"></script>
-->
<script src="lib/Seed.js"></script>
<script src="lib/gl-matrix/common.js"></script>
<script src="lib/gl-matrix/mat4.js"></script>
<script src="lib/gl-matrix/vec3.js"></script>
<script>
// fps
window.onload = function() {
eval(unescape("(function()%7Bvar%20script%3Ddocument.createElement(%27script%27)%3Bscript.src%3D%27http://github.com/mrdoob/stats.js/raw/master/build/stats.min.js%27%3Bdocument.body.appendChild(script)%3Bscript%3Ddocument.createElement(%27script%27)%3Bscript.innerHTML%3D%27var%20interval%3DsetInterval(function()%7Bif(typeof%20Stats%3D%3D%5C%27function%5C%27)%7BclearInterval(interval)%3Bvar%20stats%3Dnew%20Stats()%3Bstats.domElement.style.position%3D%5C%27fixed%5C%27%3Bstats.domElement.style.left%3D%5C%270px%5C%27%3Bstats.domElement.style.top%3D%5C%270px%5C%27%3Bstats.domElement.style.zIndex%3D%5C%2710000%5C%27%3Bdocument.body.appendChild(stats.domElement)%3BsetInterval(function()%7Bstats.update()%3B%7D,1000/60)%3B%7D%7D,100)%3B%27%3Bdocument.body.appendChild(script)%3B%7D)()%3B"))
};
</script>
<style>

  body, html {
    padding: 0;
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  canvas ~ canvas {
    width: 70px;
    height: 70px;
  }
</style>

<canvas id="canvas"></canvas>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
  attribute vec2 position; // -1..1
  attribute vec2 texture;  //  0..1

  uniform vec2 viewport;
  uniform vec2 scroll;
  uniform mat4 matrix;
  uniform mat4 camera;
  uniform mat4 projection;
  uniform mat4 orientation;
  uniform int step;

  varying vec2 pixel;
  varying vec2 tile;

  void main() {
    tile = texture;
    // prepare textures
    if (step == 1 || step == 2) {
      vec2 pos = texture * 2.0 - 1.0;
      gl_Position = vec4(pos, 0, 1);
    // render game field
    } else {
      vec2 pos = position;
      pos.y = - pos.y - 0.5;
      pixel = ((pos + 1.0) / 2.0 * viewport) + scroll;
      pixel.y *= 2.0;
      
      gl_Position = vec4(position, 0, 1) * matrix * projection *camera;
    }
  }
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;

  //
  // Description : Array and textureless GLSL 2D simplex noise function.
  //      Author : Ian McEwan, Ashima Arts.
  //  Maintainer : ijm
  //     Lastmod : 20110822 (ijm)
  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
  //               Distributed under the MIT License. See LICENSE file.
  //               https://github.com/ashima/webgl-noise
  // 

  vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
  }

  float snoise(vec2 v)
    {
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                       -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
  // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);

  // Other corners
    vec2 i1;
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    // x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

  // Permutations
    i = mod289(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                  + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }


  // game map textures
  uniform sampler2D terrain;
  uniform sampler2D subterrain;
  uniform sampler2D overlay;
  uniform sampler2D objects;

  // prepared textures
  uniform sampler2D transitions;
  uniform sampler2D obstruction;

  // terrain textures and masks
  uniform sampler2D spritesLandscape;
  uniform sampler2D spritesTerrain;
  uniform sampler2D spritesTransitions;

  // object textures
  uniform sampler2D sprites64x64;
  uniform sampler2D sprites64x160;
  uniform sampler2D sprites192x160;

  uniform vec2 mapSize;
  uniform vec2 atlasSize;
  uniform float tileSize;
  uniform int step;
  uniform mat4 projection;
  uniform mat4 orientation;

  varying vec2 pixel;
  varying vec2 tile;

  vec2 getTilePosition(vec2 tile) {
    vec2 cell = floor(tile * mapSize);

    return vec2(
      (cell.x - cell.y) * (tileSize) 
        + (mapSize.x * tileSize ) - tileSize, 
      (cell.x + cell.y) * (tileSize / 2.0) 
    );
  }

  vec2 getCoordinates() {
    return (tile * mapSize - floor(tile * mapSize));
  }

  vec2 getPosition(vec2 shift) {
    return (floor(tile * mapSize) + shift) / mapSize;
  }

  float getVariation(vec2 position, float seed) {
    return (snoise(floor(position * mapSize * seed)) + 1.0) / 2.0;
  }

  float getRandom(vec2 position, float range, float seed) {
    return floor(getVariation(position, seed) * range);
  }

  vec4 getTerrain(vec2 shift) {
    vec2 position = getPosition(shift);
    return floor(texture2D(terrain, position) * 255.0);
  }

  vec4 getSubterrain(vec2 shift) {
    vec2 position = getPosition(shift);
    return floor(texture2D(subterrain, position) * 255.0);
  }

  float checkTransition(float x, float a, float b, float c, float d, float e, float f, float g, float h) {
    // 4 sides
    if (x > b && x > h && x > d && x > f)
      return 9.0;
    // 3 sides
    if (x > b && x > d && x > f)
      return 17.0;
    if (x > h && x > d && x > f)
      return 18.0;
    if (x > h && x > b && x > f)
      return 19.0;
    if (x > h && x > d && x > b)
      return 20.0;
    // 2 sides + corner
    if (x > h && x > f && x > c)
      return 21.0;
    if (x > h && x > b && x > e)
      return 22.0;
    if (x > b && x > d && x > g)
      return 23.0;
    if (x > a && x > f && x > d)
      return 24.0;
    // 2 sides
    if (x > f && x > h)
      return 1.0;
    if (x > h && x > b)
      return 3.0;
    if (x > b && x > d)
      return 5.0;
    if (x > f && x > d)
      return 7.0;
    if (x > b && x > f)
      return 15.0;
    if (x > h && x > d)
      return 16.0;
    // 1 side + 2 corners
    if (x > h && x > c && x > e)
      return 25.0;
    if (x > b && x > g && x > e)
      return 26.0;
    if (x > d && x > a && x > g)
      return 27.0;
    if (x > f && x > a && x > c)
      return 28.0;
    // 1 sides + 1 corner
    if (x > h && x > c)
      return 29.0;
    if (x > h && x > e)
      return 30.0;
    if (x > b && x > e)
      return 31.0;
    if (x > b && x > g)
      return 32.0;
    if (x > d && x > g)
      return 33.0;
    if (x > d && x > a)
      return 34.0;
    if (x > f && x > a)
      return 35.0;
    if (x > f && x > c)
      return 36.0;
    // 1 side
    if (x > h)
      return 2.0;
    if (x > b)
      return 4.0;
    if (x > d)
      return 6.0;
    if (x > f)
      return 8.0;
    // 4 corners
    if (x > a && x > c && x > g && x > e)
      return 47.0;
    // 3 corners
    if (x > g && x > a && x > e)
      return 43.0;
    if (x > g && x > a && x > c)
      return 44.0;
    if (x > a && x > c && x > e)
      return 45.0;
    if (x > c && x > g && x > e)
      return 46.0;
    // 2 corners
    if (x > g && x > a)
      return 37.0;
    if (x > a && x > c)
      return 38.0;
    if (x > c && x > e)
      return 39.0;
    if (x > g && x > e)
      return 40.0;
    if (x > a && x > e)
      return 41.0;
    if (x > g && x > c)
      return 42.0;
    // a corner
    if (x > g)
      return 11.0;
    if (x > a)
      return 12.0;
    if (x > c)
      return 13.0;
    if (x > e)
      return 14.0;
    return 0.0;
  }

  vec4 getTransition(vec4 location, vec2 shift) {
    vec4 a = getTerrain(shift + vec2(-1, -1));
    vec4 b = getTerrain(shift + vec2(0, -1));
    vec4 c = getTerrain(shift + vec2(1, -1));
    vec4 d = getTerrain(shift + vec2(1, 0));
    vec4 e = getTerrain(shift + vec2(1, 1));
    vec4 f = getTerrain(shift + vec2(0, 1));
    vec4 g = getTerrain(shift + vec2(-1, 1));
    vec4 h = getTerrain(shift + vec2(-1, 0));

    return vec4(
      checkTransition(location.r, a.r, b.r, c.r, d.r, e.r, f.r, g.r, h.r),
      checkTransition(location.g, a.g, b.g, c.g, d.g, e.g, f.g, g.g, h.g),
      checkTransition(location.b, a.b, b.b, c.b, d.b, e.b, f.b, g.b, h.b),
      checkTransition(location.a, a.a, b.a, c.a, d.a, e.a, f.a, g.a, h.a)
    );
  }

  vec4 getPreparedTerrainTransition(vec4 location, vec2 shift) {
    return floor(texture2D(transitions, getPosition(shift)) * 255.0);
  }

  vec4 getObject(vec2 shift) {
    return floor(texture2D(objects, getPosition(shift)) * 255.0);
  }

  vec4 getPreparedObtruction(vec2 shift) {
    return floor(texture2D(obstruction, getPosition(shift)) * 255.0);
  }

  vec4 getObstruction(vec4 location, vec2 shift) {
    vec4 result = vec4(0,0,0,0);
    // RGB channels encode up to 24 sprite obstructions
    // (originating at different tiles) over a tile
    if (getObject(shift + vec2(4, 4)).r > 100.0)
      result.r += 128.0;
    if (getObject(shift + vec2(3, 4)).r > 100.0)
      result.r += 64.0;
    if (getObject(shift + vec2(4, 3)).r > 100.0)
      result.r += 32.0;
    if (getObject(shift + vec2(2, 4)).r > 200.0)
      result.r += 16.0;
    if (getObject(shift + vec2(3, 3)).r > 100.0)
      result.r += 8.0;
    if (getObject(shift + vec2(4, 2)).r > 200.0)
      result.r += 4.0;
    if (getObject(shift + vec2(1, 4)).r > 200.0)
      result.r += 2.0;
    if (getObject(shift + vec2(2, 3)).r > 100.0)
      result.r += 1.0;

    if (getObject(shift + vec2(3, 2)).r > 100.0)
      result.g += 128.0;
    if (getObject(shift + vec2(4, 1)).r > 200.0)
      result.g += 64.0;
    if (getObject(shift + vec2(0, 4)).r > 200.0)
      result.g += 32.0;
    if (getObject(shift + vec2(1, 3)).r > 200.0)
      result.g += 16.0;
    if (getObject(shift + vec2(2, 2)).r > 100.0)
      result.g += 8.0;
    if (getObject(shift + vec2(3, 1)).r > 200.0)
      result.g += 4.0;
    if (getObject(shift + vec2(4, 0)).r > 200.0)
      result.g += 2.0;
    if (getObject(shift + vec2(0, 3)).r > 200.0)
      result.g += 1.0;

    if (getObject(shift + vec2(1, 2)).r > 100.0)
      result.b += 128.0;
    if (getObject(shift + vec2(2, 1)).r > 100.0)
      result.b += 64.0;
    if (getObject(shift + vec2(3, 0)).r > 200.0)
      result.b += 32.0;
    if (getObject(shift + vec2(0, 2)).r > 200.0)
      result.b += 16.0;
    if (getObject(shift + vec2(1, 1)).r > 0.0)
      result.b += 8.0;
    if (getObject(shift + vec2(2, 0)).r > 200.0)
      result.b += 4.0;
    if (getObject(shift + vec2(0, 1)).r > 0.0)
      result.b += 2.0;
    if (getObject(shift + vec2(1, 0)).r > 0.0)
      result.b += 1.0;

    // alpha channel for subterrain obstructions
    if (getSubterrain(shift + vec2(2, 2)).a != 0.0)
      result.a += 64.0;
    if (getSubterrain(shift + vec2(1, 2)).a != 0.0)
      result.a += 32.0;
    if (getSubterrain(shift + vec2(2, 1)).a != 0.0)
      result.a += 16.0;
    if (getSubterrain(shift + vec2(1, 1)).a != 0.0)
      result.a += 8.0;
    if (getSubterrain(shift + vec2(0, 1)).a != 0.0)
      result.a += 4.0;
    if (getSubterrain(shift + vec2(1, 0)).a != 0.0)
      result.a += 2.0;
    if (getSubterrain(shift).a > 0.0) // fixme?
      result.a += 1.0;
    return result;
  }


  vec4 getColor(sampler2D texture, vec2 locals, vec2 position, vec2 grid, vec2 shift, vec2 translate) {
    vec2 offset = position * grid;
    vec2 start = getTilePosition(tile + shift / mapSize);
    vec2 diff = ((pixel - locals) - start);
    vec2 point = locals + diff + translate;
    point.x += (grid.x - tileSize * 2.0) / 2.0;
    point.y += (grid.y - tileSize);
    if (point.x > 0.0 && point.x < grid.x && point.y > 0.0 && point.y < grid.y)
      return texture2D(texture, (point + offset) / atlasSize);
    else 
      return vec4(0, 0, 0, 0);
  }

  // get color of a mask pixel
  // also composes any combination of corners from separate corner sprites
  vec4 checkTransitionColor(vec2 locals, vec2 position, vec2 shift, vec2 translate) {
    vec2 coordinates = (tile * mapSize - floor(tile * mapSize));
    float x = position.x;
    float sprite = 0.0;
    // composable tiles use pieces of regular tiles to create more orientations
    if (x > 20.0) {
      // sw
      if (coordinates.x < 0.5 && coordinates.y > 0.5) {
        // corners
        if (x == 47.0 || x == 37.0 || x == 40.0 || x == 42.0 || x == 43.0 || x == 44.0 || x == 46.0 || x == 26.0 || x == 27.0 || x == 23.0 || x == 32.0 || x == 33.0) {
          sprite = 11.0;
        }
        if (x == 25.0 || x == 29.0 || x == 30.0)
          sprite = 2.0;
        if (x == 28.0 || x == 35.0 || x == 36.0)
          sprite = 8.0;
        if (x == 21.0)
          sprite = 1.0;
        if (x == 22.0)
          sprite = 3.0;
        if (x == 24.0)
          sprite = 7.0;
      }
      // ne
      if (coordinates.x < 0.5 && coordinates.y < 0.5) {
        if (x == 47.0 || x == 37.0 || x == 38.0 || x == 41.0 || x == 43.0 || x == 44.0 || x == 45.0 || x == 27.0 || x == 28.0 || x == 27.0 || x == 24.0 || x == 34.0|| x == 35.0) {
          sprite = 12.0;
        }
        if (x == 26.0 || x == 31.0 || x == 32.0)
          sprite = 4.0;
        if (x == 25.0 || x == 29.0 || x == 30.0)
          sprite = 2.0;
        if (x == 21.0)
          sprite = 1.0;
        if (x == 22.0)
          sprite = 3.0;
        if (x == 23.0)
          sprite = 5.0;
      }
      // ne
      if (coordinates.x > 0.5 && coordinates.y < 0.5) {
        if (x == 47.0 || x == 38.0 || x == 39.0 || x == 42.0 || x == 44.0 || x == 45.0 || x == 46.0 || x == 26.0 || x == 25.0 || x == 28.0 || x == 21.0 || x == 29.0|| x == 36.0) {
          sprite = 13.0;
        }
        if (x == 26.0 || x == 31.0 || x == 32.0)
          sprite = 4.0;
        if (x == 27.0 || x == 33.0 || x == 34.0)
          sprite = 6.0;
        if (x == 22.0)
          sprite = 3.0;
        if (x == 23.0)
          sprite = 5.0;
        if (x == 24.0)
          sprite = 7.0;
      }
      // se
      if (coordinates.x > 0.5 && coordinates.y > 0.5) {
        if (x == 47.0 || x == 39.0 || x == 40.0 || x == 41.0 || x == 43.0 || x == 45.0 || x == 46.0 || x == 26.0 || x == 25.0 || x == 22.0 || x == 30.0 || x == 31.0) {
          sprite = 14.0;
        }
        if (x == 27.0 || x == 33.0 || x == 34.0)
          sprite = 6.0;
        if (x == 28.0 || x == 35.0 || x == 36.0)
          sprite = 8.0;
        if (x == 21.0)
          sprite = 1.0;
        if (x == 23.0)
          sprite = 5.0;
        if (x == 24.0)
          sprite = 7.0;
      }
      if (sprite == 0.0) {
        return vec4(0, 0, 0, 1);
      } else {
        x = sprite;
      }
    }
    position.x = x - 1.0;
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    return getColor(spritesTransitions, locals, position, grid, vec2(0, 0), translate);
  }

  vec2 getTranslation(vec2 shift) {
    vec2 coordinates = getCoordinates();
    vec2 translate = vec2(0,0);
    float pixel = 1.0 - 1.0 / tileSize;
    if ((coordinates.x > pixel && coordinates.y >  1.0 / tileSize / 2.0) 
    || (coordinates.y > pixel && coordinates.x > 1.0 / tileSize / 2.0) )
      translate.y -= 1.0;


    return translate;
  }

  vec4 getBestCorner(vec2 pos, float threshold, float variation, vec2 first, vec2 second, vec2 third) {
    vec4 result = vec4(0,0,0,0);
    float results = 0.0;
    vec4 a = result;
    vec4 b = result;
    vec4 c = result;
    vec4 corner = floor(texture2D(terrain, pos + first / mapSize) * 255.0);
    if (corner.r < threshold) {
      a = corner;
      results++;
    }
    corner = floor(texture2D(terrain, pos + second / mapSize) * 255.0);
    if (corner.r < threshold) {
      if (results == 1.0)
        b = corner;
      else
        a = corner;
      results++;
    }
    corner = floor(texture2D(terrain, pos + third / mapSize) * 255.0);
    if (corner.r < threshold) {
      if (results == 2.0)
        c = corner;
      if (results == 1.0)
        b = corner;
      else
        a = corner;
      results++;
    }
    if (results > 0.0) {
      float choice = floor(results * (variation));
      if (choice == 2.0)
        result = c;
      else if (choice == 1.0)
        result = b;
      else
        result = a;
    }
    return result;
  }

  vec4 getCorner(vec2 locals, vec2 shift, vec2 translate, float threshold) {
    vec2 coordinates = getCoordinates();
    vec2 now = floor(tile * mapSize + shift);
    float variation = getVariation(floor(now + coordinates * tileSize), 1.0);
    float halfSize = tileSize / 2.0;
    float thirdSize = tileSize / 1.5;
    float sixthSize = tileSize / 3.0;
    vec2 pos = now / mapSize;
    if (coordinates.x < 1.0 / 3.0 && coordinates.y < 1.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, -1), vec2(-1, 0), vec2(0, -1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x > 2.0 / 3.0 && coordinates.y < 1.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, -1), vec2(0, -1), vec2(1,0));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x > 2.0 / 3.0 && coordinates.y > 2.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, 1), vec2(1, 0), vec2(0, 1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 3.0 && coordinates.y > 2.0 / 3.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, 1), vec2(-1, 0), vec2(0, 1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 2.0 && coordinates.y < 1.0 / 2.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(-1, 0), vec2(-1, 0), vec2(-1, -1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x > 1.0 / 2.0 && coordinates.y < 1.0 / 2.0){
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(0, -1), vec2(1, 0), vec2(1, -1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x > 1.0 / 2.0 && coordinates.y > 1.0 / 2.0){
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(1, 0), vec2(0, 1), vec2(1, 1));
      if (corner.r > 0.0)
        return corner;
    }
    if (coordinates.x < 1.0 / 2.0 && coordinates.y > 1.0 / 2.0) {
      vec4 corner = getBestCorner(pos, threshold, variation, vec2(0, 1), vec2(-1, 0), vec2(-1, 1));
      if (corner.r > 0.0)
        return corner;
    }
    /**/
    return vec4(0,0,0,0);
  }

  vec4 getTerrainColor(vec2 locals, vec2 shift, vec4 location, vec4 transition) {
    vec2 translate = getTranslation(shift);
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    vec2 here = vec2(0, 0);
    float variation = getRandom(getPosition(shift), 4.0, 1.0);
    vec2 terrain = vec2(variation, location.r - 1.0);
    if (transition.r > 0.0) {
      vec2 mask = vec2(transition.r, 1);
      vec4 masked = checkTransitionColor(locals, mask, here, translate);
      if (masked.a == 0.0) {
        vec4 corner = getCorner(locals, shift, translate, location.r);
        if (corner.r > 0.0)
          terrain.y = corner.r - 1.0;
      } else {
        //return masked;
      }
    }
    return getColor(spritesTerrain, locals, terrain, grid, vec2(0, 0), translate);
  }

  vec4 getOverlayColor(vec2 locals, vec2 shift, vec4 location, vec4 transition) {
    vec2 translate = getTranslation(shift);
    if (location.b == 0.0)
      return vec4(0, 0, 0, 0);
    if (transition.b > 0.0) {
      vec2 mask = vec2(transition.b, 0);
      vec4 masked = checkTransitionColor(locals, mask, vec2(0, 0), translate);
      if (!(masked.r == 0.0 && masked.g == 0.0 && masked.b == 0.0 && masked.a == 1.0))
        return masked;
    }
    float variation = getRandom(shift, 4.0, 1.0);
    vec2 terrain = vec2(variation, 4.0);
    vec2 grid = vec2(tileSize * 2.0, tileSize);
    return getColor(spritesTerrain, locals, terrain, grid, vec2(0, 0), translate);
  }

  vec4 getObjectColor(vec2 locals, vec2 shift) {
    vec2 now = tile * mapSize + shift;
    if (now.y > mapSize.y || now.x > mapSize.x)
      return vec4(0, 0, 0, 0);
    vec2 pos = floor(now) / mapSize;
    vec4 location = texture2D(objects, pos);
    vec4 object = floor(location * 255.0);
    vec2 translate = vec2(0, 0);

    if (object.x > 0.0) {
      object.xy -= 1.0;
      if (object.x >= 200.0) {
        vec2 grid192x160 = vec2(tileSize * 6.0, tileSize * 5.0);
        object.x -= 200.0;
        return getColor(sprites192x160, locals, object.xy, grid192x160, shift, translate);
      } else if (object.x >= 100.0) {
        object.x -= 100.0;
        vec2 grid64x160 = vec2(tileSize * 2.0, tileSize * 5.0);
        return getColor(sprites64x160, locals, object.xy, grid64x160, shift, translate);
      } else {
        vec2 grid64x64 = vec2(tileSize * 2.0, tileSize * 2.0);
        return getColor(sprites64x64, locals, object.xy, grid64x64, shift, translate);
      }
    }
    return vec4(0, 0, 0, 0);
  }

  vec4 blend(vec4 overlay, vec4 color, float mode) {
    if (color.a == 1.0)
      return color;
    if (overlay.a == 0.0)
      return color;

    overlay.a *= mode;
    overlay.rgb *= overlay.a;
    color.rgb *= color.a;
    vec3 blended = overlay.rgb + ((1.0-overlay.a)*color.rgb);
    float alpha = color.a + (1.0-color.a)*overlay.a;
    return vec4(blended, 1);
  }

  float getZValue(vec2 shift, float heighted) {
    vec2 pos = getPosition(shift);
    vec4 location = texture2D(subterrain, pos);
    if (location.r == 0.0 && location.g == 0.0 && location.b == 0.0 && location.a == 0.0)
      location = texture2D(terrain, pos);
    float rating = location.a - 0.5;
    float height = floor(rating * 128.0);
    vec2 origin = getPosition(shift + vec2(height, height) - heighted);
    return location.a + floor(origin.y * mapSize.y + origin.x) * mapSize.x * mapSize.y;
  }

  vec4 getZColor(sampler2D texture, vec2 locals, vec2 position, vec2 grid, vec2 shift, vec2 translate, vec4 color) {
    float score = getZValue(shift, 1.0);
    if (color.a == 0.0 || color.a < score) {
      vec4 result = getColor(texture, locals, position, grid, shift, translate);
      if (result.a > 0.0) {
        result.a = score;
        return result;
      }
    }
    return color;
  }

  vec4 getZObjectColor(vec2 locals, vec2 shift, float threshold, vec4 color) {
    float score = 0.0;
    if (threshold > 0.0)
      score = getZValue(shift, 0.0);
    if (threshold <= score) {
      vec4 result = getObjectColor(locals, shift);
      return blend(result, color, 1.0);
    }
    return color;
  }

  vec4 getSubterrainColor(vec4 obstruction, vec2 locals, vec2 shift, vec4 location, vec4 transition) {
    vec4 color = vec4(0, 0, 0, 0);
    vec2 translate = vec2(0, 0);
    vec2 grid = vec2(tileSize * 2.0, tileSize * 2.0);
    if (obstruction.a >= 64.0) {
      obstruction.a -= 64.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(2, 2)), 4.0, 1.0), 0);
      vec2 subshift = vec2(2, 2);  
      vec4 origin = getSubterrain(subshift);
      float height = floor((origin.a - 127.0) / 2.0) ;
      if (height > 0.0) {
        subshift += vec2(height, height) - 1.0;
        origin = getTerrain(subshift);
      }
      vec4 next = getTerrain(subshift - 1.0);
      if (origin.a != next.a)
        color = getZColor(spritesLandscape, locals, position, grid, vec2(2, 2), translate, color);
    }
    if (obstruction.a >= 32.0) {
      obstruction.a -= 32.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(1, 2)), 4.0, 1.0), 0);
      vec2 subshift = vec2(1, 2);  
      vec4 origin = getSubterrain(subshift);
      float height = floor((origin.a - 127.0) / 2.0) ;
      if (height > 0.0) {
        subshift += vec2(height, height) - 1.0;
        origin = getTerrain(subshift);
      }
      vec4 next = getTerrain(subshift - vec2(0, 1));
      if (origin.a != next.a)
        color = getZColor(spritesLandscape, locals, position, grid, vec2(1, 2), translate, color);
    }
    if (obstruction.a >= 16.0) {
      obstruction.a -= 16.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(2, 1)), 4.0, 1.0), 0);
      vec2 subshift = vec2(2, 1);  
      vec4 origin = getSubterrain(subshift);
      float height = floor((origin.a - 127.0) / 2.0) ;
      if (height > 0.0) {
        subshift += vec2(height, height) - 1.0;
        origin = getTerrain(subshift);
      }
      vec4 next = getSubterrain(subshift - vec2(1, 0));
      if (origin.a != next.a)
        color = getZColor(spritesLandscape, locals, position, grid, vec2(2, 1), translate, color);
    } 
    if (obstruction.a >= 8.0) {
      obstruction.a -= 8.0;
      if (color.a == 0.0) {
        vec2 subshift = vec2(1,1);
        vec4 origin = getSubterrain(subshift);
        float height = floor((origin.a - 127.0) / 2.0) ;
        if (height > 0.0) {
          subshift = vec2(height, height);
          origin = getTerrain(subshift);
        }
        vec4 originTransition = getPreparedTerrainTransition(origin, subshift);
        if (originTransition.a > 0.0) {
          vec2 pos = vec2(originTransition.a, 5.0);
          color = checkTransitionColor(locals, pos, vec2(0, 0), getTranslation(shift));
        }
        if (color.a > 0.0) {
          color = getTerrainColor(locals, subshift, origin, originTransition);
        }
        if (color.a > 0.0)
          color.a = getZValue(vec2(1,1), 1.0);
      }
      vec2 position = vec2(getRandom(getPosition(shift + vec2(1, 1)), 4.0, 1.0), 0);
      color = getZColor(spritesLandscape, locals, position, grid, vec2(1, 1), translate, color);
    }
    if (obstruction.a >= 4.0) {
      obstruction.a -= 4.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(0, 1)), 4.0, 1.0), 0);
      color = getZColor(spritesLandscape, locals, position, grid, vec2(0, 1), translate, color);
    }
    if (obstruction.a >= 2.0) {
      obstruction.a -= 2.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(1, 0)), 4.0, 1.0), 0);
      color = getZColor(spritesLandscape, locals, position, grid, vec2(1, 0), translate, color);
    }
    if (obstruction.a >= 1.0) {
      obstruction.a -= 1.0;
      vec2 position = vec2(getRandom(getPosition(shift + vec2(0, 0)), 4.0, 1.0), 0);
      color = getZColor(spritesLandscape, locals, position, grid, vec2(0, 0), translate, color);
    }
    return color;
  }

  // obstruction map encodes offsets to neighbour tiles
  // that have sprites big enough to obstruct given pixel

  // this function decodes that information
  // and does necessary texture lookups
  vec4 getObstructionColor(vec2 locals, vec2 shift, vec4 location, vec4 transition) {
    vec4 color = vec4(0, 0, 0, 0);
    vec4 subterrain = vec4(0, 0, 0, 0);
    vec4 obstruction = getPreparedObtruction(shift);
    float threshold = 0.0;
    if (obstruction.a > 0.0) {
      subterrain = getSubterrainColor(obstruction, locals, shift, location, transition);
      if (subterrain.a > 0.0) {
        threshold = subterrain.a;
        subterrain.a = 1.0;
      }
    }
    // 4th row
    if (obstruction.r >= 128.0) {
      obstruction.r -= 128.0;
      color = getZObjectColor(locals, shift + vec2(4, 4), threshold, color);
    }
    if (obstruction.r >= 64.0) {
      obstruction.r -= 64.0; 
      color = getZObjectColor(locals, shift + vec2(3, 4), threshold, color);
    }
    if (obstruction.r >= 32.0) {
      obstruction.r -= 32.0; 
      color = getZObjectColor(locals, shift + vec2(4, 3), threshold, color);
    }

    // 3d row
    if (obstruction.r >= 16.0) {
      obstruction.r -= 16.0;
      color = getZObjectColor(locals, shift + vec2(2, 4), threshold, color);
    }
    if (obstruction.r >= 8.0) {
      obstruction.r -= 8.0;
      color = getZObjectColor(locals, shift + vec2(3, 3), threshold, color);
    }
    if (obstruction.r >= 4.0) {
      obstruction.r -= 4.0;
      color = getZObjectColor(locals, shift + vec2(4, 2), threshold, color);
    }
    if (obstruction.r >= 2.0) {
      obstruction.r -= 2.0;
      color = getZObjectColor(locals, shift + vec2(1, 4), threshold, color);
    }
    if (obstruction.r >= 1.0) {
      obstruction.r -= 1.0;
      color = getZObjectColor(locals, shift + vec2(2, 3), threshold, color);
    }
    if (obstruction.g >= 128.0) {
      obstruction.g -= 128.0;
      color = getZObjectColor(locals, shift + vec2(3, 2), threshold, color);
    }
    if (obstruction.g >= 64.0) {
      obstruction.g -= 64.0;
      color = getZObjectColor(locals, shift + vec2(4, 1), threshold, color);
    }


    // 2nd row
    if (obstruction.g >= 32.0) {
      obstruction.g -= 32.0;
      color = getZObjectColor(locals, shift + vec2(0, 4), threshold, color);
    }
    if (obstruction.g >= 16.0) {
      obstruction.g -= 16.0;
      color = getZObjectColor(locals, shift + vec2(1, 3), threshold, color);
    }
    if (obstruction.g >= 8.0) {
      obstruction.g -= 8.0;
      color = getZObjectColor(locals, shift + vec2(2, 2), threshold, color);
    }
    if (obstruction.g >= 4.0) {
      obstruction.g -= 4.0;
      color = getZObjectColor(locals, shift + vec2(3, 1), threshold, color);
    }
    if (obstruction.g >= 2.0) {
      obstruction.g -= 2.0;
      color = getZObjectColor(locals, shift + vec2(4, 0), threshold, color);
    }
    if (obstruction.g >= 1.0) {
      obstruction.g -= 1.0;
      color = getZObjectColor(locals, shift + vec2(0, 3), threshold, color);
    }
    if (obstruction.b >= 128.0) {
      obstruction.b -= 128.0;
      color = getZObjectColor(locals, shift + vec2(1, 2), threshold, color);
    }

    if (obstruction.b >= 64.0) {
      obstruction.b -= 64.0;
      color = getZObjectColor(locals, shift + vec2(2, 1), threshold, color);
    }
    if (obstruction.b >= 32.0) {
      obstruction.b -= 32.0;
      color = getZObjectColor(locals, shift + vec2(3, 0), threshold, color);
    }

    // 1st row
    if (obstruction.b >= 16.0) {
      obstruction.b -= 16.0;
      color = getZObjectColor(locals, shift + vec2(0, 2), threshold, color);
    }
    if (obstruction.b >= 8.0) {
      obstruction.b -= 8.0;
      color = getZObjectColor(locals, shift + vec2(1, 1), threshold, color);
    }
    if (obstruction.b >= 4.0) {
      obstruction.b -= 4.0;
      color = getZObjectColor(locals, shift + vec2(2, 0), threshold, color);
    }
    if (obstruction.b >= 2.0) {
      obstruction.b -= 2.0;
      color = getZObjectColor(locals, shift + vec2(0, 1), threshold, color);
    }
    if (obstruction.b >= 1.0) {
      obstruction.b -= 1.0;
      color = getZObjectColor(locals, shift + vec2(1, 0), threshold, color);
    }
    if (obstruction.a > 0.0) {
      if (threshold > 0.0) {
        float height = (threshold - floor(threshold)) * 255.0 - 127.0;
      }
      color = blend(subterrain, color, 1.0);
    }


    return color;
  }

  void main() {
    vec2 locals = pixel - getTilePosition(tile);
    vec2 shift = vec2(0, 0);
    vec4 location = getTerrain(shift);

    if (step == 0) {
      vec4 transition = getPreparedTerrainTransition(location, shift);
      vec4 color = vec4(0,0,0,0);
       color = blend(color, getObstructionColor(locals, shift, location, transition), 1.0);
      if (color.a < 1.0) {
        color = blend(color, getObjectColor(locals, shift), 1.0);
        if (color.a < 1.0) {
          color = blend(color, getOverlayColor(locals, shift, location, transition), 1.0);
          if (color.a < 1.0) {
            color = blend(color, getTerrainColor(locals, shift, location, transition), 1.0);
          }
        }
      }
      gl_FragColor = color;
    }
    if (step == 1) {
      gl_FragColor = getTransition(location, shift) / 255.0;
    } else if (step == 2) {
      gl_FragColor = getObstruction(location, shift) / 255.0;
      //if (gl_FragColor.x != 0.0)
      //  gl_FragColor.a = 1.0;
    }
  }
</script>


<script>
  var options = {
    zoom: 2,
    mapSize: 32,
    tileSize: 32
  };
  var seed = parseFloat(location.search.split('seed=')[1]) || Math.random();
  
  Math.seedrandom(seed)
  var random2 = Math.random;
  Math.seedrandom(seed)

  var canvas    = document.getElementById('canvas');

  var gl        = GL(canvas);
  var vertex    = GL.Script(gl, '2d-vertex-shader')
  var fragment  = GL.Script(gl, '2d-fragment-shader')
  var program   = GL.Program(gl, [vertex, fragment])

  // look up where the vertex data needs to go.
  var position  = GL.Program.Attribute(gl, program, 'position');
  var texture   = GL.Program.Attribute(gl, program, 'texture');

  var step        = GL.Program.Uniform(gl, program, 'step');
  var tileSize    = GL.Program.Uniform(gl, program, 'tileSize');
  var mapSize     = GL.Program.Uniform(gl, program, 'mapSize');
  var atlasSize   = GL.Program.Uniform(gl, program, 'atlasSize');
  var viewport    = GL.Program.Uniform(gl, program, 'viewport');
  var scroll      = GL.Program.Uniform(gl, program, 'scroll');
  var matrix      = GL.Program.Uniform(gl, program, 'matrix');
  var camera      = GL.Program.Uniform(gl, program, 'camera');
  var projection  = GL.Program.Uniform(gl, program, 'projection');
  var orientation = GL.Program.Uniform(gl, program, 'orientation');

  var terrain     = GL.Program.Uniform(gl, program, 'terrain');
  var subterrain  = GL.Program.Uniform(gl, program, 'subterrain');
  var overlay     = GL.Program.Uniform(gl, program, 'overlay');
  var objects     = GL.Program.Uniform(gl, program, 'objects');
  var obstruction = GL.Program.Uniform(gl, program, 'obstruction');
  var transitions = GL.Program.Uniform(gl, program, 'transitions');


  var geometry = [
    //x  y    u  v
      0,-0.5, 1, 1,
     -1, 0,   0, 1,
      1, 0,   1, 0,

     -1, 0,   0, 1,
      0, 0.5, 0, 0,
      1, 0,   1, 0,
  ];

  var Textures = {
    'spritesTerrain':     'examples/sprites/terrain.png',
    'spritesLandscape':   'examples/sprites/landscape.png',
    'spritesTransitions': 'examples/sprites/transitions.png',
    'sprites64x64':       'examples/sprites/sprites64x64.png',
    'sprites64x160':      'examples/sprites/sprites64x160.png',
    'sprites192x160':     'examples/sprites/sprites192x160.png'
  };


  var textures = {};
  var loading = [];

  for (var name in Textures) {
    !function(name) {
      loading.push(name);
      load(Textures[name], function() {
        var texture = textures[name] = {
          image: this,
          location: GL.Program.Uniform(gl, program, name) 
        }
        loading.pop();
        if (!loading.length)
          render()
      })
    }(name)
  }
  var generateTerrainAndSubterrain = function() {
    var terrain = getImageData('terrain');
    var subterrain = getImageData('subterrain');
    var obstruction = getImageData('obstruction');
    for (var i = 0, j = Math.pow(options.mapSize, 2); i < j; i++) {
      // R: terrain
      terrain.data[i * 4 + 0] = Math.floor(Math.random() * 3) + 1;
      // G: overlay
      terrain.data[i * 4 + 1] = 0//Math.floor(Math.random() * 4) + 1;
      // B: water
      terrain.data[i * 4 + 2] = matchRegion(terrain, i, options.mapSize, water) && 1;
      // A: level
      terrain.data[i * 4 + 3] = 127;
      var regioned = matchRegion(terrain, i, options.mapSize, mountians);
      if (Math.random() > 0.9 || regioned) {
        if (location.search.indexOf('flat') > -1)
          var height = 1;
        else
          var height = Math.floor(random2() * (regioned ? 0 : 2)) + 1;
        terrain.data[i * 4 + 3] += height * 2;
        for (var k = 0; k < height; k++) {
          var pos = i - k * options.mapSize - k;
          var diff = height - k;
          var alpha = terrain.data[i * 4 + 3] - (diff - 1) * 2;
          if (alpha >= subterrain.data[pos * 4 + 3]) {
            subterrain.data[pos * 4 + 0] = terrain.data[i * 4 + 0]
            subterrain.data[pos * 4 + 1] = terrain.data[i * 4 + 1]
            subterrain.data[pos * 4 + 2] = terrain.data[i * 4 + 2]
            subterrain.data[pos * 4 + 3] = alpha
          }
        }
      }
    }
    return {
      terrain: terrain,
      subterrain: subterrain
    };
  }

  var water = [
    [12, 10, 8, 5],
    //[21, 10, 0, 0],
    [15, 17, 0, 3],
    [14, 20, 0, 0],
    [12, 21, 1, 0],
    [14, 18, 5, 0],
    [18, 17, 0, 3],
    [17, 21, 0, 0],
  ];

  var mountians = [
    [8, 14, 1, 1],
    [10, 20, 0, 1],
    [11, 19, 0, 1],
    [12, 21, 0, 0]
  ]

  var matchRegion = function(data, i, width, regions) {
    var x = i % width
    var y = Math.floor(i / width);
    for (var pool, j = 0; pool = regions[j++];) {
      if (x >= pool[0] && y >= pool[1] && x <= pool[0] + pool[2] && y <= pool[1] + pool[3]) {
        return pool;
        break;
      }
    }
  }

  var generateOverlay = function() {
    var data = getImageData('overlay');
    for (var i = 0, j = Math.pow(options.mapSize, 2); i < j; i++) {
      // cover
      data.data[i * 4 + 0] = 0;
      // cover mask
      data.data[i * 4 + 1] = Math.floor(Math.random() * 2);
      // water
      data.data[i * 4 + 2] = matchRegion(data, i, options.mapSize, water) ? 1 : 0;
    }
    return data;
  }

  var obstructObject = function(obstruction, i, x, y, channel, value) { 
  }
  var generateObject = function(data, obstruction, i, size, x, y) {
    if (size == null)
      var size = Math.floor(Math.random() * 3);
    switch (size) {
      case 0:
        data.data[i * 4 + 0] = Math.floor(Math.random() * 9) + 1;
        data.data[i * 4 + 1] = Math.floor(Math.random() * 2) + 1;

        break;
      case 1:
        data.data[i * 4 + 0] = (x != null ? x : Math.floor(Math.random() * 6)) + 100 + 1;
        data.data[i * 4 + 1] = (y != null ? y : Math.floor(Math.random() * 1)) + 1;
        break;
      case 2:
        data.data[i * 4 + 0] = (x != null ? x : Math.floor(Math.random() * 2)) + 200 + 1;
        data.data[i * 4 + 1] = (y != null ? y : Math.floor(Math.random() * 1)) + 1;
        break;
    }
    return data;
  }

  var canvases = {};
  var getCanvas = function(name) {
    var canvas = canvases[name];
    if (!canvas) {
      canvas = document.createElement('canvas')
      var context = canvas.getContext('2d');
      canvas.height = options.mapSize;
      canvas.width = options.mapSize;
      canvases[name] = canvas;
    }
    return canvas;
  }

  var datas = {};
  var getImageData = function(name) {
    var data = datas[name];
    if (!data) {
      var canvas = getCanvas(name);
      var data = canvas.getContext('2d').createImageData(options.mapSize, options.mapSize);
      datas[name] = data;
    }
    return data; 
  }

  var setImageData = function(name, data) {
    getCanvas(name).getContext('2d').putImageData(data, 0, 0)
  }

  var generateObjectsAndObstruction = function() {
    var objects = getImageData('objects')
    var obstruction = getImageData('obstruction');


    generateObject(objects, obstruction, 425, 2, 1, 0);
    generateObject(objects, obstruction, 425 + 64 - 2, 2, 1, 0);
    generateObject(objects, obstruction, 425 + 193, 2, 1, 0);
    
    //for (var i = 0; i < options.mapSize * options.mapSize / 10 ; i++) {
    //  var pos = Math.floor(Math.random() * (options.mapSize * options.mapSize))
    //  generateObject(objects, obstruction, pos);
    //}

    return {
      objects: objects,
      obstruction: obstruction
    }
  }
  //gl.enable(gl.CULL_FACE);
  //gl.enable(gl.DEPTH_TEST)
  var buffer;
  var transitionsBuffer;
  var transitionsTexture;
  var obstructionBuffer;
  var obstructionTexture;
  var objectsAndObstruction = generateObjectsAndObstruction()
  var terrainAndSubterrain = generateTerrainAndSubterrain()

  var terrainData = terrainAndSubterrain.terrain;
  var subterrainData = terrainAndSubterrain.subterrain;
  var overlayData = generateOverlay()
  var objectsData = objectsAndObstruction.objects;
  var obstructionData = objectsAndObstruction.obstruction;

  document.body.appendChild(getCanvas('terrain'));
  document.body.appendChild(getCanvas('subterrain'));
  document.body.appendChild(getCanvas('objects'));
  document.body.appendChild(getCanvas('obstruction'));
  document.body.appendChild(getCanvas('overlay'));

  var depth = window.devicePixelRatio || 1;
  var view = true
  window.onresize = function() {
    view = true;
  }
  var i = 0;
  var limit = 100;//Infinity;
  var repeat = 1;
  function getFrameBuffer(gl, width, height) {
    var buffer = gl.createFramebuffer();
    buffer.width = width;
    buffer.height = height;
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
    var texture = GL.Texture(gl, 5, null, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return {
      buffer: buffer,
      texture: texture
    }
  }
  var transitionsBuffer
  function renderTransitionsTexture() {
    if (!transitionsBuffer) {
      var fbo = getFrameBuffer(gl, options.mapSize, options.mapSize);
      transitionsBuffer = fbo.buffer;
      transitionsTexture = fbo.texture;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, transitionsBuffer);
    gl.viewport(0, 0, transitionsBuffer.width, transitionsBuffer.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  function renderObstructionTexture() {
    if (!obstructionBuffer) {
      var fbo = getFrameBuffer(gl, options.mapSize, options.mapSize);
      obstructionBuffer = fbo.buffer;
      obstructionTexture = fbo.texture;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, obstructionBuffer);
    gl.viewport(0, 0, obstructionBuffer.width, obstructionBuffer.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  function render() {
    //if (i > 0)
    if (location.search.indexOf('profile') > -1) console.profile(i);
    for (var r = 0; r < repeat; r++) {
    //console.profile(i);
    // provide texture coordinates for the map.

    if (!buffer) {
      // upload & assign textures
      GL.Texture(gl, 0, terrainData, true);
      GL.Texture(gl, 1, subterrainData, true);
      GL.Texture(gl, 2, overlayData, true);
      GL.Texture(gl, 3, objectsData, true);

      gl.uniform1i(terrain, 0);
      gl.uniform1i(subterrain, 1);
      gl.uniform1i(overlay, 2);
      gl.uniform1i(objects, 3);

      buffer = GL.Buffer(gl, 'array', new Float32Array(geometry));

      // set meta data
      gl.uniform2f(atlasSize, textures.spritesTerrain.image.width, textures.spritesTerrain.image.height);
      gl.uniform2f(mapSize, options.mapSize, options.mapSize);
      gl.uniform1f(tileSize, 32);

      // iterate geometry in pairs of two
      gl.enableVertexAttribArray(position);
      gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0);

      gl.enableVertexAttribArray(texture);
      gl.vertexAttribPointer(texture, 2, gl.FLOAT, false, 16, 8);

      var k = 6;
      for (var name in textures) {
        if (!textures[name].location)
          continue
        k++;
        gl.uniform1i(textures[name].location, k);
        GL.Texture(gl, k, textures[name].image, true)
      }
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    }
    if (view) {
      canvas.width = window.innerWidth * depth;
      canvas.height = window.innerHeight * depth;
      gl.uniformMatrix4fv(camera, false, getCamera());
      gl.uniformMatrix4fv(matrix, false, getMatrix());
      gl.uniformMatrix4fv(projection, false, getProjection());
      gl.uniformMatrix4fv(orientation, false, getOrientation());
      view = null;
    }
    gl.uniform1i(step, 2);
    renderObstructionTexture();
    gl.uniform1i(step, 1);
    renderTransitionsTexture();
    gl.uniform1i(step, 0);

    
    
    // set resolution
    var h = gl.drawingBufferHeight;
    var w = gl.drawingBufferWidth
    var max = options.mapSize * options.tileSize;
    var total = Math.max(h, w)
    var ratio = w / h;

    gl.uniform2f(viewport, options.mapSize * options.tileSize * 2, options.mapSize * options.tileSize);
    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    gl.viewport(0, 0, w, h);

    gl.uniform2f(scroll, 0, 0);

    // Attach pre-rendered textures
    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, transitionsTexture);
    gl.uniform1i(transitions, 5);
    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_2D, obstructionTexture);
    gl.uniform1i(obstruction, 6);

    // Draw the thing.
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
    if (location.search.indexOf('profile') > -1) console.profileEnd(i);
    // schedule next frame
    if (i < limit)
      requestAnimationFrame(function() {
        render()
      });
    i++;
    for (var name in canvases)
      if (canvases[name].offsetHeight)
        setImageData(name, getImageData(name));
  }


  function load(src, callback) {
    var img = new Image;
    img.onload = callback;
    img.src = src;
    return img;
  }

  function getCamera() {
    var direction = mat4.create()
    var camera = mat4.create()
    
    // set up camera direction
    //mat4.lookAt(direction, [0, 0, 1], [0, 0, 0], [0, 1, 0])

    // create and apply perspective
    //mat4.perspective(camera, 90 * Math.PI / 180, window.innerWidth / window.innerHeight, 0.1, 1000)

    //mat4.ortho(camera, -1, 1, -1, 1, -1, 1)

    // handle canvas aspect ratio (makes everything squared)
    camera[0] = 1 / (window.innerWidth / window.innerHeight)

    //mat4.multiply(camera, camera, direction)
    //mat4.multiply(camera, camera, projection)


    return camera
  }

  function getOrientation() {

    var orientation = mat4.create()
    mat4.rotate(orientation, orientation, 90 * Math.PI / 180, [0, 0, 1]);

    mat4.rotate(orientation, orientation, 60 * Math.PI / 180, [1, 0 , 0]);
    mat4.rotate(orientation, orientation, 45 * Math.PI / 180, [0, 0, 1]);
    //mat4.scale(orientation, orientation, [1, 1, 1])

    return orientation;
  };

  function getProjection() {
    // rotate view (isometric projection)
    var projection = mat4.create()
    //mat4.rotate(projection, projection, 45 * Math.PI / 180, [0, 0//, 1]);
    //mat4.rotate(projection, projection, 60 * Math.PI / 180, [1, 0 //, 0]);
    return projection;
  }

  function getMatrix() {
    var matrix = mat4.create()

    // scale by ratio
    // mat4.scale(matrix, matrix, [ (mapImage.width / mapImage.height), 1, 1])

    // scale map up, to make units equal device pixels
    var ratio = (options.mapSize * options.tileSize / window.innerHeight) * options.zoom// * 1.4
    mat4.scale(matrix, matrix, [ ratio, ratio, ratio])
    return matrix
  }

</script>

